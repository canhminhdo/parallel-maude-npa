load maude-npa.maude
load socket/buffered-socket.maude
load utils/queue.maude
load utils/loading.maude
load common.maude .

mod PARALLEL-MAUDE-NPA is
    pr PARALLEL-GENERIC-TOOL .
    pr REQUEST .
    pr MESSAGE-CONVERTER .

    vars O O' CLIENT : Oid .
    var  A : AttributeSet .
    vars Nodes BStep Step Sess BSize : Bound .
    vars Rem? : Bool .
    vars IS : IdSystem .
    vars IST IST' IST1 IST2 HistoryIST HistoryIST' : IdSystemSet .
    vars M : Module .
    var GS : GrammarList .
    var F : Filters .
    vars DATA S : String .
    vars State : IdSystemSetTuple .
    vars C N C1 C2 C3 : Nat .

    rl [Initialize] : < O : Client |
        status : idle,
        A >
        Initialize(O, O', M, GS, F, BStep, Nodes, Sess, Rem?, HistoryIST, IST)
    => < O : Client |
        status : initialized,
        m : M,
        gs: GS,
        filter : F,
        nodes : Nodes,
        sess : Sess,
        rem : Rem?,
        jobs : empty,
        history : empty,
        A >
        [print "[Initialize]"] .

    rl [CreatedSocket] : < O : Client |
        status : initialized,
        A >
        CreatedSocket(O, socketManager, CLIENT)
    => < O : Client |
        status : waiting,
        socket : CLIENT,
        A >
        Send(CLIENT, O, getJob)
        Receive(CLIENT, O)
        [print "[CreatedSocket]"] .

    rl [Sent] : < O : Client | status : waiting, A > Sent(O, CLIENT)
    => < O : Client | status : waiting, A > [print "[Sent]"] .

    rl [GetJob] : < O : Client |
        status : sending,
        jobs : empty,
        A >
        Sent(O, CLIENT)
    => < O : Client |
        status : waiting,
        jobs : empty,
        A >
        Send(CLIENT, O, getJob)
        [print "[GetJob]"] .

    crl [SendData] : < O : Client |
        status : sending,
        jobs : IST,
        batchSize : BSize,
        A >
        Sent(O, CLIENT)
    => < O : Client |
        status : sending,
        jobs : IST1,
        batchSize : BSize,
        A >
        Send(CLIENT, O, state2string(< empty, IST2, empty >))
    if C := #jobs(IST)
    /\ C > 0
    /\ < IST1, IST2 > := getBatchJobsToSend(IST, BSize)
    [print "[SendData]"] .

    crl [Received] : < O : Client |
        status : waiting,
        m : M,
        gs: GS,
        filter : F,
        nodes : Nodes,
        sess : Sess,
        rem : Rem?,
        history : HistoryIST,
        jobs : empty,
        batchSize : BSize,
        A >
        Received(O, CLIENT, DATA)
    =>  < O : Client |
        status : sending,
        m : M,
        gs: GS,
        filter : F,
        nodes : Nodes,
        sess : Sess,
        rem : Rem?,
        history : (HistoryIST' IST'), --- update history if any
        jobs : IST1,
        batchSize : BSize,
        A >
        Send(CLIENT, O, state2string(< empty, IST2, empty >))
    if State := string2state(DATA)
    /\ State =/= errIdSystemSetTuple
    /\ IST := jobs(State)
    /\ HistoryIST' := (HistoryIST IST)
    /\ IST' := filterStateWithHistory(M, HistoryIST, nextBackNarrowParallel(M, GS, F, Nodes, IST))
    /\ < IST1, IST2 > := getBatchJobsToSend(IST', BSize)
    /\ C := #jobs(IST')
    [print "[Received] & [HandleJob] & [SendData] #IST = " C] .

    op getBatchJobsToSend : IdSystemSet Bound -> IdSystemSetPair .
    eq getBatchJobsToSend(IST, BSize) = if BSize == unbounded then < empty, IST > else getBatchJobsToSend*(IST, BSize, empty) fi .

    op getBatchJobsToSend* : IdSystemSet Nat IdSystemSet -> IdSystemSetPair .
    eq getBatchJobsToSend*(IS IST, s(N), IST') = getBatchJobsToSend*(IST, N, IS IST') .
    eq getBatchJobsToSend*(IST, 0, IST') = < IST, IST' > .
    eq getBatchJobsToSend*(empty, N, IST') = < empty, IST' > .

    crl [ReceivedError] : < O : Client |
        status : waiting,
        m : M,
        gs: GS,
        filter : F,
        nodes : Nodes,
        sess : Sess,
        rem : Rem?,
        history : HistoryIST,
        A >
        Received(O, CLIENT, DATA)
    => < O : Client |
        status : stopping,
        m : M,
        gs: GS,
        filter : F,
        nodes : Nodes,
        sess : Sess,
        rem : Rem?,
        history : HistoryIST,
        A >
        CloseSocket(CLIENT, O)
    if State := string2state(DATA)
    /\ State == errIdSystemSetTuple
    [print "[ReceivedError] errIdSystemSetTuple"] .

    rl [ClosedSocket] : < O : Client | A > ClosedSocket(O, CLIENT, S)
    => < O : Client | none > [print "[ClosedSocket]"] .
endm