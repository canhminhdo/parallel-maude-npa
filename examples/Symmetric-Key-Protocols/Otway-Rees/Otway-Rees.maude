----  Otway-Rees Protocol

---------------------------------------------------
--- We modify only the relevant MAUDE-NPA modules
---------------------------------------------------

fmod PROTOCOL-EXAMPLE-SYMBOLS is
  --- Importing sorts IMsg, Fresh, Public
  protecting DEFINITION-PROTOCOL-RULES .

  ----------------------------------------------------------
  --- Overwrite this module with the syntax of your protocol
  --- Notes:
  --- * Sort IMsg and Fresh are special and imported
  --- * Every sort must be a subsort of IMsg
  --- * No sort can be a supersort of IMsg
  ----------------------------------------------------------

  --- Sort Information
  sorts  UName SName Name Key Nonce  Masterkey Sessionkey .
  subsort Name Nonce  Key < IMsg .
  subsort Masterkey  Sessionkey < Key .
  subsort SName UName < Name .
  subsort Name < Public . --- This is quite relevant and necessary
  --- Nonce operator
  op n : Name Fresh -> Nonce [frozen] .
  op mr : Name Fresh -> Nonce [frozen] . --- Nonce, run identifier

  --- User names
  ops a b i : -> UName .

  --- Server name
  op s : ->  SName .

  --- MKey
  op mkey : Name Name -> Masterkey [frozen] .

  --- Seskey
  op seskey : Name Name Nonce -> Sessionkey [frozen] .

  ---encrypt
  op e  : Key IMsg -> IMsg [frozen] .
  op d : Key IMsg -> IMsg  [frozen] .

  --- Concatenation
  op _;_ : IMsg IMsg -> IMsg [frozen gather (e E)] .

endfm

fmod PROTOCOL-EXAMPLE-ALGEBRAIC is
  protecting PROTOCOL-EXAMPLE-SYMBOLS .

  ----------------------------------------------------------
  --- Overwrite this module with the algebraic properties
  --- of your protocol
  ----------------------------------------------------------

 eq d(K:Key, e(K:Key, Z:IMsg )) = Z:IMsg [variant] .
 eq e(K:Key, d(K:Key, Z:IMsg )) = Z:IMsg [variant] .


endfm

fmod PROTOCOL-SPECIFICATION is
  protecting PROTOCOL-EXAMPLE-SYMBOLS .
  protecting DEFINITION-PROTOCOL-RULES .
  protecting DEFINITION-CONSTRAINTS-INPUT .

  ----------------------------------------------------------
  --- Overwrite this module with the strands
  --- of your protocol
  ----------------------------------------------------------

  var A B S  : UName .
  var r r' r'' r''' r# r## rM : Fresh .
  vars TS NA NMA NB NMB NMS : Nonce .
  vars M1 M2 MA MB1 MB2 MS N M : IMsg .
  var K : Key .
  var SK : Sessionkey .

  eq STRANDS-DOLEVYAO
  =  :: nil :: [ nil | +(A), nil ]  &
     :: nil :: [ nil | +(s), nil ] &
     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &
     :: nil :: [ nil | -(K), -(M), +(e(K,M)), nil ] &
     :: nil :: [ nil | -(N), -(M), +(M ; N) , nil ] &
     :: nil :: [ nil | -(M ; N), +(M) , nil ] &
     :: nil :: [ nil | -(M ; N), +(N) , nil ] &
     :: nil :: [ nil | +(mkey(A,i)), nil ]  &
     :: nil :: [ nil | +(mkey(i,A)), nil ]  &
     :: nil :: [ nil | +(mkey(i,s)), nil ]
  [nonexec] .

  eq STRANDS-PROTOCOL
  --- A -> B : M,A,B,E(Kas:Na,M,A,B). Encrypted message readable only by the server S
  --- B -> S : M,A,B,E(Kas:Na,M,A,B),E(Kbs:Nb,M,A,B)
  --- S	-> B : M,E(Kas:Na,Kab),E(Kbs:Nb,Kab)
  --- B	-> A : M,E(Kas:Na,Kab)
  --- Alice's Strand.
   = :: r,rM ::
     [ nil | +(n(A,rM) ; A ; B ; e(mkey(A,s) , n(A,r) ; n(A,rM) ; A ; B)),
             -(n(A,rM) ; e(mkey(A,s) , n(A,r) ; SK)), nil ]
   &
     :: r ::
   --- Bob's Strand.
     [ nil | -(NMA ; A ; B ; M1),
             +(NMA ; A ; B ; M1 ; e(mkey(B,s) , n(B,r) ; NMA ; A ; B)),
             -(NMA ; MA ; e(mkey(B,s) , n(B,r) ; SK)),
             +(NMA ; MA), nil ]
   &
     :: r ::
     --- Server's Strand
    [ nil |  -(NMA ; A ; B ; e(mkey(A,s), NA ; NMA ; A ; B)
                           ; e(mkey(B,s) , NB ; NMA ; A ; B)),
             +(NMA ; e(mkey(A,s) , NA ; seskey(A , B , n(S,r)))
                   ; e(mkey(B,s) , NB ; seskey(A , B , n(S,r)))) , nil]

  [nonexec] .

eq ATTACK-STATE(0) =
:: r,rM ::
--- A normal execution of the protocol
    [ nil ,  +(n(a,rM) ; a ; b ; e(mkey(a,s) , n(a,r) ; n(a,rM) ; a ; b)),
             -(n(a,rM) ; e(mkey(a,s) , n(a,r) ; SK)) | nil ]
     || empty
     || nil
     || nil
     || nil
[nonexec] .

eq ATTACK-STATE(1) =
:: r,rM ::
--- An execution where the intruder finds out the Session key generated by the server
    [ nil ,  +(n(a,rM) ; a ; b ; e(mkey(a,s) , n(a,r) ; n(a,rM) ; a ; b)),
             -(n(a,rM) ; e(mkey(a,s) , n(a,r) ; SK)) | nil ]
     || SK inI
     || nil
     || nil
     || nil
[nonexec] .


eq ATTACK-STATE(2) =
:: r,rM ::
--- An execution where Bob completed the protocol believing that talks to Alice, but it is not so.
    [ nil ,  +(n(a,rM) ; a ; b ; e(mkey(a,s) , n(a,r) ; n(a,rM) ; a ; b)),
             -(n(a,rM) ; e(mkey(a,s) , n(a,r) ; SK)) | nil ]
|| empty
|| nil
|| nil
|| never
 *** Pattern for authentication
     (:: r' ::
     [ nil | -(NMA ; a ; b ; e(mkey(A,s) , n(A,r) ; n(A,rM) ; A ; B)),
             +(NMA ; a ; b ; e(mkey(A,s) , n(A,r) ; n(A,rM) ; A ; B) ; MB1),
             -(NMA ; e(mkey(A,s) , n(A,r) ; SK) ; MB2),
             +(NMA ; e(mkey(A,s) , n(A,r) ; SK)), nil ]
      & S:StrandSet || K:IntruderKnowledge)

[nonexec] .
endfm

--- THIS HAS TO BE THE LAST LOADED MODULE !!!!
select MAUDE-NPA .
--- fmod MAUDE-NPA is
---   protecting GENERIC-TOOLS .
--- endfm
