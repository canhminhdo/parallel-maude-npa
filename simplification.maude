mod JOB-HANDLING is
    pr META-INTERPRETER .
    pr PARALLEL-CONFIG .
    pr MAP{Worker,IdSystemSet} .
    pr SET{Worker} .
    pr PARAMETER-GLOBAL .

    sorts J2J W2W .

    vars O MI : Oid .
    vars N C C1 C2 C3 C4 C5 : Nat .
    var Sess : Bound .
    vars IST IST' HistoryIST : IdSystemSet .
    vars IS IS' : IdSystem .
    vars W W' : Queue{Worker} .
    var W2J : Map{Worker,IdSystemSet} .

    op <_|_> : IdSystemSet IdSystemSet -> J2J .
    op <_,_> : Queue{Worker} Queue{Worker} -> W2W .

    *** [NEW] distribute a job to each worker in step 2.1
    op getJobs : IdSystemSet Nat -> J2J .
    op getJobs* : IdSystemSet Nat IdSystemSet -> J2J .
    --- precondition: N <= | IST |
    eq getJobs(IST, N) = getJobs*(IST, N, empty) .
    ceq getJobs*(IS IST, N, IST') = getJobs*(IST, sd(N, 1), IST' IS) if N > 0 .
    eq getJobs*(IST, 0, IST') = < IST | IST' > .

    op handleOneJobByWorkers : Oid Queue{Worker} IdSystem IdSystemSet -> Configuration .
    eq handleOneJobByWorkers(O, MI | W, IS, IS' IST)
    =   reduceTerm(MI, O,
            'MAUDE-NPA-EXT,
            'simplifyTwo[
                upTerm(IS),
                upTerm(IS')
            ]
        )
        handleOneJobByWorkers(O, W, IS, IST) .
    eq handleOneJobByWorkers(O, emptyq, IS, empty) = none .

    op handleOneHJobByWorkers : Oid Queue{Worker} IdSystem IdSystemSet -> Configuration .
    eq handleOneHJobByWorkers(O, MI | W, IS, IS' IST)
    =   reduceTerm(MI, O,
            'MAUDE-NPA-EXT,
            'simplifyHOne[
                upTerm(IS'),
                upTerm(IS)
            ]
        )
        handleOneHJobByWorkers(O, W, IS, IST) .
    eq handleOneHJobByWorkers(O, emptyq, IS, empty) = none .

    *** calculate the number of workers for step 2.1 (simplificationL)
    op neededWorkersForSimL : Nat Nat -> Nat .
    eq neededWorkersForSimL(C, N)
    =   if C < simBatch
        then 1
        else
            if (C quo simBatch) > 1
            then
                if (C quo simBatch) > N then N else (C quo simBatch) fi
            else
                if (C rem simBatch) >= (simBatch quo 2) then 2 else 1 fi
            fi
        fi .

    *** distribute a job evenly to each worker in step 2.1
    op handleJobsLByWorkers : Oid Map{Worker,IdSystemSet} -> Configuration .
    eq handleJobsLByWorkers(O, (MI |-> IST, W2J))
    =   if IST == empty then
            none
        else
            reduceTerm(MI, O,
                'MAUDE-NPA-EXT,
                'simplifyByImplicationL[
                    upTerm(IST)
                ]
            )
            handleJobsLByWorkers(O, W2J)
        fi .
    eq handleJobsLByWorkers(O, empty) = none .

    *** calculate the number of workers for step 2.2 (simplificationH)
    op neededWorkersForSimH : Nat Nat Nat -> Nat .
    eq neededWorkersForSimH(C1, C2, N)
    =   if C1 * C2 < simBatchH
        then 1
        else neededWorkersForSimH*(C1, C2, N)
        fi .
    op neededWorkersForSimH* : Nat Nat Nat -> Nat .
    ceq neededWorkersForSimH*(C1, C2, N)
    =   if C5 < 1
        then 1
        else
            if C5 > 1
            then
                (if C5 > N then N else C5 fi)
            else
                (if (C2 rem C4) >= (C4 quo 2) then 2 else 1 fi)
            fi
        fi
    if C3 := (simBatchH quo C1)
    /\ C4 := (if C3 == 0 then 1 else C3 fi) --- the minimum number of states should be assigned to each worker
    /\ C5 := C2 quo C4 . --- #workers needed

    *** distribute a job to each worker in step 2.2
    op handleJobsByWorkers : Oid Map{Worker,IdSystemSet} IdSystemSet -> Configuration .
    eq handleJobsByWorkers(O, (MI |-> IST, W2J), HistoryIST)
    =   if IST == empty then
            none
        else
            reduceTerm(MI, O,
                'MAUDE-NPA-EXT,
                'simplifyByImplicationH[
                    upTerm(HistoryIST),
                    upTerm(IST)
                ]
            )
            handleJobsByWorkers(O, W2J, HistoryIST)
        fi .
    eq handleJobsByWorkers(O, empty, HistoryIST) = none .

    *** pick up a needed number of workers from workers
    op getWorkers : Queue{Worker} Nat -> W2W .
    eq getWorkers(W, N) = getWorkers*(W, N, emptyq) .
    op getWorkers* : Queue{Worker} Nat Queue{Worker} -> W2W .
    eq getWorkers*(MI | W, N, W')
    =   if N > 0
        then getWorkers*(W, sd(N, 1), MI | W')
        else < MI | W, W' >
        fi .
    eq getWorkers*(emptyq, N, W') = < emptyq, W' > .

    *** divide jobs evenly for each worker
    op initW2J : Queue{Worker} -> Map{Worker,IdSystemSet} .
    eq initW2J(MI | W) =  MI |-> empty, initW2J(W) .
    eq initW2J(emptyq) = empty .

    op produceJobs2Workers : Queue{Worker} IdSystemSet -> Map{Worker,IdSystemSet} .
    eq produceJobs2Workers(W, IST) = produceJobs2Workers*(W, W, initW2J(W), IST) .

    op produceJobs2Workers* : Queue{Worker} Queue{Worker} Map{Worker,IdSystemSet} IdSystemSet -> Map{Worker,IdSystemSet} .
    eq produceJobs2Workers*(W, MI | W', (MI |-> IST', W2J), IS IST)
    = produceJobs2Workers*(W, W', (MI |-> (IS IST'), W2J), IST) .

    eq produceJobs2Workers*(W, emptyq, W2J, IST) = produceJobs2Workers*(W, W, W2J, IST) .
    eq produceJobs2Workers*(W, W', W2J, empty) = W2J .
endm

mod SIMPLIFICATION is
    pr JOB-HANDLING .

    vars O MI : Oid .
    var A : AttributeSet .
    vars N N1 C C1 C2 : Nat .
    var Sess : Bound .
    vars IST IST' IST'' IST1 IST2 IST3 INIT INIT' HistoryIST : IdSystemSet .
    vars IS IS' : IdSystem .
    vars W W1 W2 : Queue{Worker} .
    var SJ : Queue{IdSystemSet} .
    vars T : Term .
    var RT : Type .
    var M : Module .
    var W2J : Map{Worker,IdSystemSet} .
    vars B B' : Bool .

    *** parallelize step 2.1 (simplifyingL) --- a NEW version
    --- start simplification with successor states
    crl [SimplificationL] : < O : Manager |
        status : startSimplifying,
        next : IST,
        passCheck : IST1,
        nextCheck : IST2,
        current : IST3,
        rmFlag : B,
        A >
    => < O : Manager |
        status : simplifying,
        next : IST,
        passCheck : empty,
        nextCheck : empty,
        current : empty,
        rmFlag : false,
        A >
    if C := #jobs(IST)
    [print "[SimplificationL] #IST = " C] .

    crl [SimplificationLDone] : < O : Manager |
        status : simplifying,
        next : IST,
        passCheck : empty,
        nextCheck : IST2,
        current : empty,
        A >
    => < O : Manager |
        status : startSimplifyingH,
        next : (IST1 IST2),
        passCheck : empty,
        nextCheck : empty,
        current : empty,
        A >
    if C := #jobs(IST)
    /\ C <= simBatch
    /\ IST1 := simplifyByImplicationL(IST) 
    [print "[SimplificationLDone]"] .

    crl [SimOne] : < O : Manager |
        status : simplifying,
        next : (IS IST),
        current : empty,
        A >
    => < O : Manager |
        status : simplifyingOne,
        next : IST,
        current : IS,
        A >
    if C := #jobs(IST)
    /\ C + 1 > simBatch 
    [print "SimplifyingOne"] .

    rl [SimOneJob] : < O : Manager |
        status : simplifyingOne,
        workers : (MI | W),
        next : (IS' IST),
        current : IS,
        rmFlag : false,
        A >
    => < O : Manager |
        status : simplifyingOne,
        workers : W,
        next : IST,
        current : IS,
        rmFlag : false,
        A >
        reduceTerm(MI, O,
            'MAUDE-NPA-EXT,
            'simplifyTwo[
                upTerm(IS),
                upTerm(IS')
            ]
        ) .

    crl [Result4SimOne] : < O : Manager |
        status : simplifyingOne,
        workers : W,
        passCheck : IST1,
        rmFlag : B,
        A >
        reducedTerm(O, MI, N, T, RT)
    => < O : Manager |
        status : simplifyingOne,
        workers : (W | MI),
        passCheck : (IST' IST1),
        rmFlag : (B or B'),
        A >
    if RT == 'ResSimPair
    /\ < B' | IST' > := downTerm(T, errRes) .

    crl [SimOneDone1] : < O : Manager |
        status : simplifyingOne,
        #workers : N,
        workers : W,
        next : empty,
        current : IS,
        passCheck : IST1,
        nextCheck : IST2,
        rmFlag : false,
        A >
    => < O : Manager |
        status : simplifying,
        #workers : N,
        workers : W,
        next : IST1,
        current : empty,
        passCheck : empty,
        nextCheck : (IS IST2),
        rmFlag : false,
        A >
    if qsize(W) == N .

    crl [SimOneDone2] : < O : Manager |
        status : simplifyingOne,
        #workers : N,
        workers : W,
        next : IST,
        current : IS,
        passCheck : IST1,
        rmFlag : true,
        A >
    => < O : Manager |
        status : simplifying,
        #workers : N,
        workers : W,
        next : (IST1 IST),
        current : empty,
        passCheck : empty,
        rmFlag : false,
        A >
    if qsize(W) == N .

    *** parallelize step 2.2 (SimplifyingH) - a NEW version for optimizing memory usage
    --- start simplification with history states
    --- crl [SimplificationH] : < O : Manager |
    ---     status : startSimplifyingH,
    ---     next : IST,
    ---     history : HistoryIST,
    ---     passCheck : IST1,
    ---     nextCheck : IST2,
    ---     current : IST3,
    ---     rmFlag : B,
    ---     A >
    --- => < O : Manager |
    ---     status : simplifyingH,
    ---     next : IST,
    ---     history : HistoryIST,
    ---     passCheck : empty,
    ---     nextCheck : empty,
    ---     current : empty,
    ---     rmFlag : false,
    ---     A >
    --- if C1 := #jobs(HistoryIST)
    --- /\ C2 := #jobs(IST)
    --- [print "[SimplificationH] #His " C1 ", #IST = " C2] .

    --- crl [SimplificationHDone] : < O : Manager |
    ---     status : simplifyingH,
    ---     history : HistoryIST,
    ---     next : IST,
    ---     passCheck : empty,
    ---     nextCheck : IST2,
    ---     current : empty,
    ---     A >
    --- => < O : Manager |
    ---     status : simplifyingHDone,
    ---     history : HistoryIST,
    ---     next : (IST' IST2),
    ---     passCheck : empty,
    ---     nextCheck : empty,
    ---     current : empty,
    ---     A >
    --- if C1 := #jobs(IST)
    --- /\ C2 := #jobs(HistoryIST) 
    --- /\ C1 * C2 <= simBatchH
    --- /\ IST' := simplifyByImplicationH(HistoryIST, IST)
    --- [print "[SimplificationHDone]"] . 

    --- rl [SimHOne] : < O : Manager |
    ---     status : simplifyingH,
    ---     next : (IS IST),
    ---     current : empty,
    ---     A >
    --- => < O : Manager |
    ---     status : simplifyingHOne,
    ---     next : IST,
    ---     current : IS,
    ---     A >
    --- [print "[simplifyingHOne]"] .

    --- rl [SimHOneJob] : < O : Manager |
    ---     status : simplifyingHOne,
    ---     workers : (MI | W),
    ---     history : (IS' HistoryIST),
    ---     current : IS,
    ---     passCheck : IST1,
    ---     rmFlag : false,
    ---     A >
    --- => < O : Manager |
    ---     status : simplifyingHOne,
    ---     workers : W,
    ---     history : HistoryIST,
    ---     current : IS,
    ---     passCheck : (IS' IST1),
    ---     rmFlag : false,
    ---     A >
    ---     reduceTerm(MI, O,
    ---         'MAUDE-NPA-EXT,
    ---         'simplifyHOne[
    ---             upTerm(IS'),
    ---             upTerm(IS)
    ---         ]
    ---     ) .

    --- crl [Result4SimHOne] : < O : Manager |
    ---     status : simplifyingHOne,
    ---     workers : W,
    ---     rmFlag : B,
    ---     A >
    ---     reducedTerm(O, MI, N, T, RT)
    --- => < O : Manager |
    ---     status : simplifyingHOne,
    ---     workers : (W | MI),
    ---     rmFlag : (B or B'),
    ---     A >
    --- if RT == 'Bool
    --- /\ B' := downTerm(T, errBool) .

    --- crl [SimHOneDone1] : < O : Manager |
    ---     status : simplifyingHOne,
    ---     #workers : N,
    ---     workers : W,
    ---     history : empty,
    ---     current : IS,
    ---     passCheck : IST1,
    ---     nextCheck : IST2,
    ---     rmFlag : false,
    ---     A >
    --- => < O : Manager |
    ---     status : simplifyingH,
    ---     #workers : N,
    ---     workers : W,
    ---     history : IST1,
    ---     current : empty,
    ---     passCheck : empty,
    ---     nextCheck : (IS IST2),
    ---     rmFlag : false,
    ---     A >
    --- if qsize(W) == N .

    --- crl [SimHOneDone2] : < O : Manager |
    ---     status : simplifyingHOne,
    ---     #workers : N,
    ---     workers : W,
    ---     history : HistoryIST,
    ---     current : IS,
    ---     passCheck : IST1,
    ---     nextCheck : IST2,
    ---     rmFlag : true,
    ---     A >
    --- => < O : Manager |
    ---     status : simplifyingH,
    ---     #workers : N,
    ---     workers : W,
    ---     history : (IST1 HistoryIST),
    ---     current : empty,
    ---     passCheck : empty,
    ---     nextCheck : IST2,
    ---     rmFlag : false,
    ---     A >
    --- if qsize(W) == N .
    
    *** parallelize step 2.2 (SimplifyingH)
    crl [SimplificationH] : < O : Manager |
        status : startSimplifyingH,
        workers : W,
        #workers : N,
        next : IST,
        history : HistoryIST,
        A >
    => < O : Manager |
        status : simplifyingH,
        workers : W,
        #workers : N,
        next : IST',
        history : HistoryIST,
        A >
    if C1 := #jobs(HistoryIST)
    /\ C2 := #jobs(IST)
    /\ N1 := neededWorkersForSimH(C1, C2, N)
    /\ N1 <= 1
    /\ IST' := simplifyByImplicationH(HistoryIST, IST)
    [print "[SimplificationH] completed #IST = " C2 ", #Hist = " C1] .

    crl [SimplificationH] : < O : Manager |
        status : startSimplifyingH,
        workers : W,
        #workers : N,
        next : IST,
        history : HistoryIST,
        A >
    => < O : Manager |
        status : (if C2 > 0 then simplifyingH else stopping fi),
        workers : W1,
        #workers : N,
        next : empty,
        history : HistoryIST,
        A >
        if C2 > 0 then handleJobsByWorkers(O, W2J, HistoryIST) else stopWorking(O, O) fi
    if C1 := #jobs(HistoryIST)
    /\ C2 := #jobs(IST)
    /\ N1 := neededWorkersForSimH(C1, C2, N)
    /\ N1 > 1
    /\ < W1, W2 > := getWorkers(W, N1)
    /\ W2J := produceJobs2Workers(W2, IST)
    [print "[SimplificationH] #usedInterpreters = " N1 ", #His " C1 ", #IST = " C2] .

    crl [Result4SimH] : < O : Manager |
        status : simplifyingH,
        workers : W,
        next : IST,
        A >
        reducedTerm(O, MI, N, T, RT)
    => < O : Manager |
        status : simplifyingH,
        workers : (W | MI),
        next : (IST IST'),
        A >
    if RT == 'IdSystemSet or-else RT == 'IdSystem
    /\ IST' := downTerm(T, errIdSystemSet)
    [print "[Result4SimH] " MI] .

    crl [SimplificationDone] : < O : Manager |
        status : simplifyingH,
        --- status : simplifyingHDone,
        #workers : N,
        workers : W,
        m : M,
        sess : Sess,
        init : INIT,
        jobs : empty,
        next : IST,
        history : HistoryIST,
        A >
    => < O : Manager |
        status : (if C > 0 then stopping else suspending fi),
        #workers : N,
        workers : W,
        m : M,
        sess : Sess,
        init : (INIT INIT'),
        jobs : IST',
        next : empty,
        history : (HistoryIST IST'),
        A >
        (if C > 0 then stopWorking(O, O) else none fi)
    if qsize(W) == N
    /\ IST =/= empty
    /\ < INIT', IST' > := searchState-CheckInit(M, Sess, HistoryIST, IST)
    /\ C := #jobs(INIT')
    /\ C1 := #jobs(IST')
    [print "<================= [SimplificationHDone] #jobs = " C1 " #init = " C "] =================>"] .

    crl [SimplificationHDoneAndStop] : < O : Manager |
        status : simplifyingH,
        --- status : simplifyingHDone, 
        #workers : N,
        workers : W,
        jobs : empty,
        next : IST,
        A >
    => < O : Manager |
        status : stopping,
        #workers : N,
        workers : W,
        jobs : empty,
        next : IST,
        A >
        stopWorking(O, O)
    if qsize(W) == N
    /\ IST == empty
    [print "<================= [SimplificationHDoneAndStop] IST = " IST "] =================>"] .
endm