load maude-npa.maude

mod MAUDE-NPA-EXT is
    pr MAUDE-NPA .

    sorts IdSystemSetPair IdSystemSetTuple .
    op <_,_> : IdSystemSet IdSystemSet -> IdSystemSetPair .
    op errIdSystemSetPair : -> IdSystemSetPair .
    op <_,_,_> : IdSystemSet IdSystemSet IdSystemSet -> IdSystemSetTuple .
    op errIdSystemSetTuple : -> IdSystemSetTuple .

    vars M : Module .
    vars GS : GrammarList .
    vars F : Filters .
    vars BStep Step Nodes Sess : Bound .
    vars C N N' : Nat .
    vars Rem? : Bool .
    vars IS : IdSystem .
    vars IST IST' IST'' INIT INIT' HistoryIST HistoryIST' : IdSystemSet .
    vars ISTP : IdSystemSetPair .

    op decN : Bound Nat -> Bound .
    eq decN(unbounded, N) = unbounded .
    eq decN(s(N), s(N')) = decN(N, N') .
    eq decN(0, N) = 0 .
    eq decN(N, 0) = N .

    op #jobs : IdSystemSet -> Nat .
    eq #jobs(IS IST) = #jobs(IST) + 1 .
    eq #jobs(empty) = 0 .

    op filterStates : Filters IdSystemSet IdSystemSet Nat -> IdSystemSet .
    eq filterStates(F, HistoryIST, IST, C)
    = if C == 1 then
       IST
    else
        simplify-theSystemSet(F,HistoryIST, IST)
    fi [print "simplify-theSystemSet"] .
    --- eq filterStates(F, HistoryIST, IST) = filterSMsgListX(F,filterIdX(F, simplify-theSystemSet(F,HistoryIST, IST))) .
    --- eq filterStates(F, HistoryIST, IST) = filterSMsgListX(F,filterIdX(F, simplifyByImplicationL(IST))) .

    op searchState-CheckInit* : Module Bound IdSystemSet IdSystemSetPair IdSystemSet Nat -> IdSystemSetPair [memo] .
    eq searchState-CheckInit*(M, Sess, HistoryIST, < INIT, IST' >, IST, C)
    = if C == 1 then
        < INIT, IST >
    else
        searchState-CheckInit(M, Sess, HistoryIST, < INIT, IST' >, IST)
    fi [print "CheckInit"] .

    op searchState-CheckInit : Module Bound IdSystemSet IdSystemSetPair IdSystemSet -> IdSystemSetPair [memo] .
    eq searchState-CheckInit(M, Sess, HistoryIST, < INIT, IST' >, empty) = < INIT, IST' > .
    eq searchState-CheckInit(M, Sess,HistoryIST, < INIT, IST' >, (IS IST))
    = if Sess =/= unbounded and-then countSessions(IS) > Sess
    then searchState-CheckInit(M, Sess, HistoryIST, < INIT, IST' >, IST)
    else if isInitialM(M,IS)
        then
            searchState-CheckInit(M, Sess, HistoryIST, < INIT IS, IST' >, IST)
        else searchState-CheckInit(M, Sess, HistoryIST,
            < INIT, if isNFSystem(M,HistoryIST,IS) then IST' else (IS IST') fi >,
            IST)
        fi
    fi .

    op searchStateMParallel : GrammarList Bound Bound Bound Bool
                    IdSystemSet IdSystemSet -> IdSystemSetTuple .
    op searchStateMParallel* : Module GrammarList Filters Bound Bound Bound Bool
                    IdSystemSet IdSystemSet IdSystemSet IdSystemSet -> IdSystemSetTuple .

    eq searchStateMParallel(GS,BStep,Nodes,Sess,Rem?,HistoryIST,IST)
    = searchStateMParallel*(pM,GS,pF,BStep,Nodes,Sess,Rem?,HistoryIST, empty, empty, IST) .

    ceq searchStateMParallel*(M,GS,F,BStep,Nodes,Sess,Rem?,HistoryIST, INIT, HistoryIST', IST)
    = if BStep == 0 or-else IST' == empty
    then
        < (INIT INIT'), IST', HistoryIST' >
    else
        searchStateMParallel*(M,GS,F,dec(BStep),Nodes,Sess,Rem?,HistoryIST IST', (INIT INIT'), HistoryIST' IST',
            IST''
        )
    fi
    if < INIT', IST' > := searchState-CheckInit(M,Sess,HistoryIST, < empty, empty >, IST)
    /\ C := #jobs(IST')
    /\ N :=  #jobs(HistoryIST')
    /\ N' :=  #jobs(HistoryIST)
    /\ IST'' := filterSMsgListX(F,filterIdX(F,
                    nextBackNarrow(M,GS,F,
                        if BStep == 1 then Nodes else unbounded fi,
                        HistoryIST IST',IST')
                ))
    [print "\nBStep = " BStep "\n#Jobs = " C "\n#His = " N "\nHisTotal = " N'] .

    op pM : -> Module .
    op pGS : -> GrammarList .
    op pF : -> Filters .

    --- parallel back narrowing wrapper function
    op nextBackNarrowParallel* : GrammarList Filters Bound IdSystemSet -> IdSystemSet [memo] .
    eq nextBackNarrowParallel*(GS, F, Nodes, IST) = nextBackNarrowParallel(pM, GS, F, Nodes, IST) .

    op nextBackNarrowParallel : Module GrammarList Filters Bound IdSystemSet -> IdSystemSet [memo] .
    eq nextBackNarrowParallel(M,GS,F:Filters,Nodes,IST)
    = filter-eachSystem#Top(F:Filters,M,GS, --- filter systems with grammars, never patterns, ...
        simplify-eachSystem#Top(F:Filters,M, --- always simplify before filtering
            simplifyGhost#Top(F:Filters, --- simplify Ghost
                createGhost#Top(M,F:Filters, --- create Ghost again
                    reactivateGhost#Top(F:Filters, --- if messages are not ghost messages anymore, reactive the messages
                        tryUnificationofKnowledge(M, --- create and check ghosts before and after
                            nextBackNarrow*(M,GS,F:Filters,Nodes,empty,IST)
                        )
                    )
                )
             )
        )
    ) .
endm

load metaInterpreter.maude

view Worker from TRIV to CONFIGURATION is
    sort Elt to Oid .
endv

mod PARALLEL-CONFIG is
    pr MAUDE-NPA-EXT .
    pr META-INTERPRETER .
    pr SET{Worker} .

    sort Status .
    ops idle initializing initialized waiting suspending working stopping terminated : -> Status .
    op status :_ : Status -> Attribute [ctor format(m o o o)] .
    op m :_ : Module -> Attribute .
    op gs :_ : GrammarList -> Attribute .
    op filter :_ : Filters -> Attribute .
    op bStep :_ : Bound -> Attribute .
    op step :_ : Bound -> Attribute .
    op nodes :_ : Bound -> Attribute .
    op sess :_ : Bound -> Attribute .
    op rem :_ : Bool -> Attribute .
    op history :_ : IdSystemSet -> Attribute .
    op jobs :_ : IdSystemSet -> Attribute .
    op next :_ : IdSystemSet -> Attribute .
    op init :_ : IdSystemSet -> Attribute .
    op depth :_ : Nat -> Attribute . --- depth needs to be explored
    op count :_ : Nat -> Attribute .
    op nWorkers :_ : Nat -> Attribute [ctor format(! o o o)] .
    op workers :_ : Set{Worker} -> Attribute [ctor format(! o o o)] .
    op stopWorking : Oid Oid -> Msg [ctor msg format (b o)] .
    op ShortIdSystem:_ : IdSystemSet-or-Error -> Msg [ctor msg] .
    op initialize : Oid Oid Module GrammarList Filters Bound Bound Bound Bool
                    IdSystemSet IdSystemSet -> Msg [ctor msg format (b o)] .

    op Manager : -> Cid [ctor] .
    op aManager : -> Oid [ctor] .
    op npa : -> Oid [ctor] .
endm

mod PARALLEL-GENERIC-TOOL is
    pr PARALLEL-CONFIG .

    vars M : Module .
    vars GS : GrammarList .
    vars F : Filters .
    vars BStep Step Nodes Sess : Bound .
    vars Rem? : Bool .
    vars IST HistoryIST : IdSystemSet .

    *** prun **********************
    op p-run : Nat Bound Filters Nat Bound -> Configuration .
    op p-run : Nat Bound Filters Nat -> Configuration .
    op p-run : Nat Bound Nat Bound -> Configuration .
    op p-run : Nat Bound Nat -> Configuration .


    eq p-run(Attack:Nat,Depth:Bound,nWorker:Nat)
    = p-run(Attack:Nat,Depth:Bound,+parallel,nWorker:Nat,1) .

    eq p-run(Attack:Nat,Depth:Bound,nWorker:Nat,Step:Bound)
    = p-run(Attack:Nat,Depth:Bound,+parallel,nWorker:Nat,Step:Bound) .

    eq p-run(Attack:Nat,Depth:Bound,F:Filters,nWorker:Nat)
    = p-run(Attack:Nat,Depth:Bound,F:Filters,nWorker:Nat,1) .

    eq p-run(Attack:Nat,Depth:Bound,F:Filters,nWorker:Nat,Step:Bound)
    = < aManager : Manager | nWorkers : nWorker:Nat, status : idle, step : Step:Bound >
    toMsg(run[0](Attack:Nat,Depth:Bound,F:Filters,unbounded)< unbounded >) .

    op toMsg : IdSystemSet -> Msg .
    eq toMsg(< M, GS, F, BStep, Nodes, Sess, Rem?, HistoryIST, IST >)
    = initialize(aManager, npa, M, GS, F, BStep, Nodes, Sess, Rem?, HistoryIST, IST) .
endm

mod PARALLEL-MAUDE-NPA is
    pr PARALLEL-GENERIC-TOOL .

    vars O O' MI : Oid .
    var  A : AttributeSet .
    vars N N' D C C' : Nat .
    vars Nodes BStep Step Sess : Bound .
    vars Rem? : Bool .
    vars IST IST' IST'' INIT INIT' HistoryIST HistoryIST' : IdSystemSet .
    var IS : IdSystem .
    vars W : Set{Worker} .
    vars T T' : Term .
    var RT : Type .
    vars M M' M'' : Module .
    var GS : GrammarList .
    var F : Filters .

    rl [CreateWorkers] : < O : Manager |
        status : idle,
        nWorkers : N,
        A >
        initialize(O, O', M, GS, F, BStep, Nodes, Sess, Rem?, HistoryIST, IST)
    => < O : Manager |
        status : initializing,
        nWorkers : N,
        workers : empty,
        m : M,
        gs : GS,
        filter : F,
        bStep : BStep,
        nodes : Nodes,
        sess : Sess,
        rem : Rem?,
        history : HistoryIST,
        jobs : IST,
        next : empty,
        init : empty,
        depth : 0,
        count : #jobs(IST),
        A >
        produceInterpreter(O, N)
    --- if (< INIT, IST' >) := searchState-CheckInit(M, Sess, HistoryIST, < empty, empty > ,IST)
    [print "[CreateWorkers]"] .

    op produceInterpreter : Oid Nat -> Configuration .
    ceq produceInterpreter(O, N) = createInterpreter(interpreterManager, O, newProcess)
        produceInterpreter(O, sd(N, 1)) if N > 0 .
    eq produceInterpreter(O, N) = none [owise] .

    crl [CreatedWorker] : < O : Manager |
        status : initializing,
        nWorkers : N,
        workers : empty,
        m : M,
        gs : GS,
        filter : F,
        nodes : Nodes,
        jobs : IST,
        A >
        createdInterpreter(O, O', MI)
    => < O : Manager |
        status : initializing,
        nWorkers : N,
        workers : empty,
        m : M,
        gs : GS,
        filter : F,
        nodes : Nodes,
        jobs : IST,
        A >
        insertModule(MI, O, M'')
        if M' := upModule('MAUDE-NPA-EXT, true)
        /\ M'' := addEqs(
            (eq 'pM.Module = upTerm(M) [none] . )
            --- (eq 'pGS.GrammarList = upTerm(GS) [none] . )
            (eq 'pF.Filters = upTerm(F) [none] . )
            , M'
        )
        [print "[CreatedWorker]"] .

    rl [InsertedModule] : < O : Manager |
        status : initializing,
        workers : W,
        A >
        insertedModule(O, MI)
    => < O : Manager |
        status : initializing,
        workers : (MI, W),
        A >
        --- showModule(MI, O, 'MAUDE-NPA-EXT, true)
        [print "[InsertedModule]"] .

    --- rl [ShowingModule] : < O : Manager | A >
    ---     showingModule(O, MI, M')
    --- => < O : Manager | A >
    ---     [print "[ShowingModule]" M'] .

    crl [CreatedWorkersDone] : < O : Manager |
        status : initializing,
        nWorkers : N,
        workers : W,
        A >
    => < O : Manager |
        status : working,
        nWorkers : N,
        workers : W,
        A >
    if | W | == N [print "[CreatedWorkersDone]"] .

    crl [AssignJob] : < O : Manager |
        status : working,
        jobs : (IS IST),
        workers : (MI, W),
        m : M,
        gs : GS,
        filter : F,
        nodes : Nodes,
        sess : Sess,
        rem : Rem?,
        history : HistoryIST,
        bStep : BStep,
        step : Step,
        A >
    => < O : Manager |
        status : working,
        jobs : IST,
        workers : W,
        m : M,
        gs : GS,
        filter : F,
        nodes : Nodes,
        sess : Sess,
        rem : Rem?,
        history : HistoryIST,
        bStep : BStep,
        step : Step,
        A >
        handleJob(O, MI, M, GS, F, Step, if BStep == 1 then Nodes else unbounded fi, Sess, Rem?, HistoryIST, IS) --- todo: need to improve
    if true [print "[AssignJob]"] .

    op handleJob : Oid Oid Module GrammarList Filters Bound Bound Bound Bool
                    IdSystemSet IdSystemSet -> Configuration .
    ceq handleJob(O, MI, M, GS, F, Step, Nodes, Sess, Rem?, HistoryIST, IS) = reduceTerm(MI, O,
        'MAUDE-NPA-EXT-ADDEDEQS,
        T
    )
    --- if T := upTerm(searchStateMParallel(GS,Step,Nodes,Sess,Rem?,HistoryIST,IS)) [print "Term = " T] .
    if T := 'searchStateMParallel[
        --- upTerm(M),
        upTerm(GS),
        --- upTerm(F),
        upTerm(Step),
        upTerm(Nodes),
        upTerm(Sess),
        upTerm(Rem?),
        upTerm(HistoryIST),
        upTerm(IS)] .
        --- [print "Term = " T] .
        --- upTerm(nextBackNarrowParallel(M, GS, F, Nodes, IS))) .
        --- upTerm(nextBackNarrow(M, GS, F, Nodes, HistoryIST, IS))) .

    crl [WorkerResult] : < O : Manager |
        status : working,
        workers : W,
        next : IST,
        init : INIT,
        history : HistoryIST,
        A >
        reducedTerm(O, MI, N, T, RT)
    => < O : Manager |
        status : working,
        workers : (W, MI),
        next : (IST IST'),
        init : (INIT INIT'),
        history : (HistoryIST HistoryIST'),
        A >
    if RT == 'IdSystemSetTuple
    /\ < INIT', IST', HistoryIST' > := downTerm(T, errIdSystemSetTuple)
    [print "[WorkerResult]"] .

    crl [Switch] : < O : Manager |
        status : working,
        nWorkers : N,
        workers : W,
        m : M,
        gs : GS,
        filter : F,
        bStep : BStep,
        step : Step,
        nodes : Nodes,
        sess : Sess,
        rem : Rem?,
        jobs : empty,
        next : IST,
        init : INIT,
        history : HistoryIST,
        depth : D,
        count : C,
        A >
    => < O : Manager |
        status : suspending,
        nWorkers : N,
        workers : W,
        m : M,
        gs : GS,
        filter : F,
        bStep : decN(BStep,Step),
        step : Step,
        nodes : Nodes,
        sess : Sess,
        rem : Rem?,
        jobs : IST'',
        next : empty,
        init : (INIT INIT'),
        history : HistoryIST,
        depth : (D + Step),
        count : C',
        A >
    if | W | == N
    /\ IST =/= empty
    /\ < INIT', IST' > := searchState-CheckInit*(M, Sess, HistoryIST, < empty, empty >, IST, C) --- filter initial and other states
    /\ IST'' := filterStates(F, HistoryIST, IST', C)
    /\ C' := #jobs(IST')--- filter sucessor states with history states
    [print "<================= [Switch at Depth " D " + " Step " #jobs = " C " -> " C' "] =================>"] .

    rl [Resuming] : < O : Manager |
        status : suspending,
        jobs : IST,
        filter : F,
        history : HistoryIST,
        bStep : BStep,
        rem : Rem?,
        A >
    => if BStep == 0 or-else IST == empty then
            --- Stop the search
            stopWorking(O, O)
            < O : Manager |
                status : stopping,
                jobs : IST,
                filter : F,
                history : HistoryIST,
                bStep : BStep,
                rem : Rem?,
                A >
        else
            < O : Manager |
                status : working,
                jobs : IST,
                filter : F,
                history : HistoryIST,
                bStep : BStep,
                rem : Rem?,
                A >
        fi .

    crl [terminate] : < O : Manager |
        status : working,
        nWorkers : N,
        workers : W,
        jobs : empty,
        next : empty,
        A >
    => < O : Manager |
        status : stopping,
        nWorkers : N,
        workers : W,
        jobs : empty,
        next : empty,
        A >
        stopWorking(O, O)
    if | W | == N
    [print "[terminate]"] .

    rl [StopWorkers] : < O : Manager | workers : W, A > stopWorking(O, O')
        => produceQuitMsg(O, W) < O : Manager | workers : W, A > [print "[StopWorkers]"] .

    op produceQuitMsg : Oid Set{Worker} -> Configuration .
    eq produceQuitMsg(O, (MI, W)) = quit(MI, O) produceQuitMsg(O, W) .
    eq produceQuitMsg(O, empty) = none .

    rl [Bye] : < O : Manager | workers : (MI, W), A > bye(O, MI) => < O : Manager | workers : W, A > [print "[Bye]"] .

    rl [CleanUp] : < O : Manager |
        status : stopping,
        workers : empty,
        filter : F,
        jobs : IST,
        rem : Rem?,
        init : INIT,
        A >
    => ShortIdSystem: if Rem? then
            changeShortSystem(F, INIT IST)
        else
            changeShortSystem(F, INIT)
        fi
        [print "[CleanUp]"] .
endm