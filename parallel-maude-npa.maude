load maude-npa.maude
load metaInterpreter.maude

fmod IQUEUE{X :: TRIV} is
    protecting BOOL .
    pr NAT .

    sort Queue{X} .
    subsort X$Elt < Queue{X} .
    op emptyq : -> Queue{X} [ctor] .
    op _|_ : Queue{X} Queue{X} -> Queue{X} [ctor assoc id: emptyq] .
    op isEmpty : Queue{X} -> Bool .
    op qsize : Queue{X} -> Nat .
    var Q : Queue{X} .
    var E : X$Elt .

    eq qsize(emptyq) = 0 .
    eq qsize(E | Q) = qsize(Q) + 1 .

    eq isEmpty(emptyq) = true .
    eq isEmpty(E | Q) = false .
endfm

mod MAUDE-NPA-EXT is
    pr MAUDE-NPA .

    sorts IdSystemSetPair IdSystemSetTuple .
    op <_,_> : IdSystemSet IdSystemSet -> IdSystemSetPair .
    op errIdSystemSetPair : -> IdSystemSetPair .
    op <_,_,_> : IdSystemSet IdSystemSet IdSystemSet -> IdSystemSetTuple .
    op errIdSystemSetTuple : -> IdSystemSetTuple .

    vars M : Module .
    vars GS : GrammarList .
    vars F : Filters .
    vars BStep Step Nodes Sess : Bound .
    vars C N N' Pid : Nat .
    vars Rem? : Bool .
    vars IS : IdSystem .
    vars IST IST' IST'' INIT INIT' HistoryIST HistoryIST' : IdSystemSet .
    vars ISTP : IdSystemSetPair .

    op pM : -> Module .
    op pGS : -> GrammarList .
    op pF : -> Filters .

    op decN : Bound Nat -> Bound .
    eq decN(unbounded, N) = unbounded .
    eq decN(s(N), s(N')) = decN(N, N') .
    eq decN(0, N) = 0 .
    eq decN(N, 0) = N .

    op #jobs : IdSystemSet -> Nat .
    eq #jobs(IS IST) = #jobs(IST) + 1 .
    eq #jobs(empty) = 0 .

    op filterStates : Filters IdSystemSet IdSystemSet Nat -> IdSystemSet .
    eq filterStates(F, HistoryIST, IST, C)
    = if C == 1 then
       IST
    else
        simplify-theSystemSet(F,HistoryIST, IST)
    fi [print "simplify-theSystemSet"] .

    op searchState-CheckInit : Module Bound IdSystemSet IdSystemSetPair IdSystemSet -> IdSystemSetPair [memo] .
    eq searchState-CheckInit(M, Sess, HistoryIST, < INIT, IST' >, empty) = < INIT, IST' > .
    eq searchState-CheckInit(M, Sess,HistoryIST, < INIT, IST' >, (IS IST))
    = if Sess =/= unbounded and-then countSessions(IS) > Sess
    then searchState-CheckInit(M, Sess, HistoryIST, < INIT, IST' >, IST)
    else if isInitialM(M,IS)
        then
            searchState-CheckInit(M, Sess, HistoryIST, < INIT IS, IST' >, IST)
        else searchState-CheckInit(M, Sess, HistoryIST,
            < INIT, if isNFSystem(M,HistoryIST,IS) then IST' else (IS IST') fi >,
            IST)
        fi
    fi .

    op searchStateMParallel : Nat GrammarList Bound Bound Bound Bool
                    IdSystemSet IdSystemSet -> IdSystemSetTuple .
    op searchStateMParallel* : Nat Module GrammarList Filters Bound Bound Bound Bool
                    IdSystemSet IdSystemSet IdSystemSet IdSystemSet -> IdSystemSetTuple .
    op searchStateMParallel** : Nat Module GrammarList Filters Bound Bound Bound Bool
                    IdSystemSet IdSystemSet IdSystemSet IdSystemSet -> IdSystemSetTuple .

    eq searchStateMParallel(Pid,GS,BStep,Nodes,Sess,Rem?,HistoryIST,IST)
    = searchStateMParallel*(Pid,pM,GS,pF,BStep,Nodes,Sess,Rem?,HistoryIST,empty,empty,IST) .

    eq searchStateMParallel*(Pid,M,GS,F,BStep,Nodes,Sess,Rem?,HistoryIST,INIT,HistoryIST',IST)
    = if BStep == 0 or-else IST == empty
    then
        < INIT, IST, HistoryIST' >
    else
        searchStateMParallel**(Pid,M,GS,F,BStep,Nodes,Sess,Rem?,HistoryIST,INIT,HistoryIST',IST)
    fi .

    ceq searchStateMParallel**(Pid,M,GS,F,BStep,Nodes,Sess,Rem?,HistoryIST,INIT,HistoryIST',IST)
    =  searchStateMParallel*(Pid,M,GS,F,dec(BStep),Nodes,Sess,Rem?,HistoryIST IST',INIT INIT',HistoryIST' IST',
            IST''
        )
    if < INIT', IST' > := searchState-CheckInit(M,Sess,HistoryIST,< empty, empty >,IST)
    /\ IST'' := filterSMsgListX(F,filterIdX(F,
                    nextBackNarrow(M,GS,F,
                        if BStep == 1 then Nodes else unbounded fi,
                        HistoryIST IST',IST')
                ))
    /\ C := #jobs(IST')
    /\ N :=  #jobs(HistoryIST')
    /\ N' :=  #jobs(HistoryIST HistoryIST')
    [print "Pid = " Pid " BStep = " BStep " #Jobs = " C " #His = " N " HisTotal = " N']
    .
endm

view Worker from TRIV to CONFIGURATION is
    sort Elt to Oid .
endv

mod PARALLEL-CONFIG is
    pr MAUDE-NPA-EXT .
    pr META-INTERPRETER .
    pr IQUEUE{Worker} .

    sort Status .
    ops idle initializing initialized waiting suspending working stopping terminated : -> Status .
    op status :_ : Status -> Attribute [ctor format(m o o o)] .
    op m :_ : Module -> Attribute .
    op gs :_ : GrammarList -> Attribute .
    op filter :_ : Filters -> Attribute .
    op bStep :_ : Bound -> Attribute .
    op step :_ : Bound -> Attribute .
    op nodes :_ : Bound -> Attribute .
    op sess :_ : Bound -> Attribute .
    op rem :_ : Bool -> Attribute .
    op history :_ : IdSystemSet -> Attribute .
    op nextHistory :_ : IdSystemSet -> Attribute .
    op jobs :_ : IdSystemSet -> Attribute .
    op next :_ : IdSystemSet -> Attribute .
    op init :_ : IdSystemSet -> Attribute .
    op depth :_ : Nat -> Attribute . --- depth needs to be explored
    op count :_ : Nat -> Attribute .
    op nWorkers :_ : Nat -> Attribute [ctor format(! o o o)] .
    op workers :_ : Queue{Worker} -> Attribute [ctor format(! o o o)] .
    op stopWorking : Oid Oid -> Msg [ctor msg format (b o)] .
    op ShortIdSystem:_ : IdSystemSet-or-Error -> Msg [ctor msg] .
    op initialize : Oid Oid Module GrammarList Filters Bound Bound Bound Bool
                    IdSystemSet IdSystemSet -> Msg [ctor msg format (b o)] .

    op Manager : -> Cid [ctor] .
    op aManager : -> Oid [ctor] .
    op npa : -> Oid [ctor] .
endm

mod PARALLEL-GENERIC-TOOL is
    pr PARALLEL-CONFIG .

    vars M : Module .
    vars GS : GrammarList .
    vars F : Filters .
    vars BStep Step Nodes Sess : Bound .
    vars Rem? : Bool .
    vars IST HistoryIST : IdSystemSet .

    *** prun **********************
    op p-run : Nat Bound Filters Nat Bound -> Configuration .
    op p-run : Nat Bound Filters Nat -> Configuration .
    op p-run : Nat Bound Nat Bound -> Configuration .
    op p-run : Nat Bound Nat -> Configuration .


    eq p-run(Attack:Nat,Depth:Bound,nWorker:Nat)
    = p-run(Attack:Nat,Depth:Bound,+parallel,nWorker:Nat,1) .

    eq p-run(Attack:Nat,Depth:Bound,nWorker:Nat,Step:Bound)
    = p-run(Attack:Nat,Depth:Bound,+parallel,nWorker:Nat,Step:Bound) .

    eq p-run(Attack:Nat,Depth:Bound,F:Filters,nWorker:Nat)
    = p-run(Attack:Nat,Depth:Bound,F:Filters,nWorker:Nat,1) .

    eq p-run(Attack:Nat,Depth:Bound,F:Filters,nWorker:Nat,Step:Bound)
    = < aManager : Manager | nWorkers : nWorker:Nat, status : idle, step : Step:Bound >
    toMsg(run[0](Attack:Nat,Depth:Bound,F:Filters,unbounded)< unbounded >) .

    op toMsg : IdSystemSet -> Msg .
    eq toMsg(< M, GS, F, BStep, Nodes, Sess, Rem?, HistoryIST, IST >)
    = initialize(aManager, npa, M, GS, F, BStep, Nodes, Sess, Rem?, HistoryIST, IST) .
endm

mod PARALLEL-MAUDE-NPA is
    pr PARALLEL-GENERIC-TOOL .

    vars O O' MI : Oid .
    var  A : AttributeSet .
    vars N N' D D' C C' Pid : Nat .
    vars Nodes BStep Step Sess : Bound .
    vars Rem? : Bool .
    vars IST IST' IST'' INIT INIT' HistoryIST HistoryIST' : IdSystemSet .
    var IS : IdSystem .
    vars W : Queue{Worker} .
    vars T T' : Term .
    var RT : Type .
    vars M M' M'' : Module .
    var GS : GrammarList .
    var F : Filters .

    rl [CreateWorkers] : < O : Manager |
        status : idle,
        nWorkers : N,
        A >
        initialize(O, O', M, GS, F, BStep, Nodes, Sess, Rem?, HistoryIST, IST)
    => < O : Manager |
        status : initializing,
        nWorkers : N,
        workers : emptyq,
        m : M,
        gs : GS,
        filter : F,
        bStep : BStep,
        nodes : Nodes,
        sess : Sess,
        rem : Rem?,
        history : HistoryIST,
        nextHistory : empty,
        jobs : IST,
        next : empty,
        init : empty,
        depth : 0,
        count : #jobs(IST),
        A >
        produceInterpreter(O, N)
        [print "[CreateWorkers]"] .

    op produceInterpreter : Oid Nat -> Configuration .
    ceq produceInterpreter(O, N) = createInterpreter(interpreterManager, O, newProcess)
        produceInterpreter(O, sd(N, 1)) if N > 0 .
    eq produceInterpreter(O, N) = none [owise] .

    crl [CreatedWorker] : < O : Manager |
        status : initializing,
        nWorkers : N,
        workers : emptyq,
        m : M,
        gs : GS,
        filter : F,
        nodes : Nodes,
        jobs : IST,
        A >
        createdInterpreter(O, O', MI)
    => < O : Manager |
        status : initializing,
        nWorkers : N,
        workers : emptyq,
        m : M,
        gs : GS,
        filter : F,
        nodes : Nodes,
        jobs : IST,
        A >
        insertModule(MI, O, M'')
        if M' := upModule('MAUDE-NPA-EXT, true)
        /\ M'' := addEqs(
            (eq 'pM.Module = upTerm(M) [none] . )
            --- (eq 'pGS.GrammarList = upTerm(GS) [none] . )
            (eq 'pF.Filters = upTerm(F) [none] . )
            , M'
        )
        [print "[CreatedWorker]"] .

    rl [InsertedModule] : < O : Manager |
        status : initializing,
        workers : W,
        A >
        insertedModule(O, MI)
    => < O : Manager |
        status : initializing,
        workers : (W | MI),
        A >
        [print "[InsertedModule] " MI] .

    crl [CreatedWorkersDone] : < O : Manager |
        status : initializing,
        nWorkers : N,
        workers : W,
        A >
    => < O : Manager |
        status : working,
        nWorkers : N,
        workers : W,
        A >
    if qsize(W) == N
    [print "[CreatedWorkersDone]"] .

    crl [AssignJob] : < O : Manager |
        status : working,
        jobs : (IS IST),
        workers : (MI | W),
        m : M,
        gs : GS,
        filter : F,
        nodes : Nodes,
        sess : Sess,
        rem : Rem?,
        history : HistoryIST,
        bStep : BStep,
        step : Step,
        A >
    => < O : Manager |
        status : working,
        jobs : IST,
        workers : W,
        m : M,
        gs : GS,
        filter : F,
        nodes : Nodes,
        sess : Sess,
        rem : Rem?,
        history : HistoryIST,
        bStep : BStep,
        step : Step,
        A >
        handleJob(O, MI, M, GS, F, Step, if BStep == 1 then Nodes else unbounded fi, Sess, Rem?, HistoryIST, IS) --- todo: need to improve
    if Pid := extractOid(MI) [print "[AssignJob] Pid = " Pid] .

    op handleJob : Oid Oid Module GrammarList Filters Bound Bound Bound Bool
                    IdSystemSet IdSystemSet -> Configuration .
    ceq handleJob(O, MI, M, GS, F, Step, Nodes, Sess, Rem?, HistoryIST, IS) = reduceTerm(MI, O,
        'MAUDE-NPA-EXT-ADDEDEQS,
        T
    )
    if Pid := extractOid(MI)
    --- /\ T := upTerm(searchStateMParallel(Pid, GS, Step, Nodes, Sess, Rem?, HistoryIST, IS))
    /\ T := 'searchStateMParallel[
        upTerm(Pid),
        --- upTerm(M),
        upTerm(GS),
        --- upTerm(F),
        upTerm(Step),
        upTerm(Nodes),
        upTerm(Sess),
        upTerm(Rem?),
        upTerm(HistoryIST),
        upTerm(IS)]
        [print "[HandleJob] " MI]
        .

    op extractOid : Oid -> Nat .
    eq extractOid(interpreter(N)) = N .

    crl [WorkerResult] : < O : Manager |
        status : working,
        workers : W,
        next : IST,
        init : INIT,
        nextHistory : HistoryIST,
        A >
        reducedTerm(O, MI, N, T, RT)
    => < O : Manager |
        status : working,
        workers : (W | MI),
        next : (IST IST'),
        init : (INIT INIT'),
        nextHistory : (HistoryIST HistoryIST'),
        A >
    if RT == 'IdSystemSetTuple
    /\ < INIT', IST', HistoryIST' > := downTerm(T, errIdSystemSetTuple)
    [print "[WorkerResult] " MI] .

    crl [Switch] : < O : Manager |
        status : working,
        nWorkers : N,
        workers : W,
        m : M,
        gs : GS,
        filter : F,
        bStep : BStep,
        step : Step,
        nodes : Nodes,
        sess : Sess,
        rem : Rem?,
        jobs : empty,
        next : IST,
        init : INIT,
        history : HistoryIST,
        nextHistory : HistoryIST',
        depth : D,
        count : C,
        A >
    => < O : Manager |
        status : suspending,
        nWorkers : N,
        workers : W,
        m : M,
        gs : GS,
        filter : F,
        bStep : decN(BStep,Step),
        step : Step,
        nodes : Nodes,
        sess : Sess,
        rem : Rem?,
        jobs : IST'',
        next : empty,
        init : (INIT INIT'),
        history : (HistoryIST HistoryIST'), --- merge next history to current history
        nextHistory : empty, --- nextHistory becomes empty
        depth : D',
        count : C',
        A >
    if qsize(W) == N
    /\ IST =/= empty
    /\ < INIT', IST' > := searchState-CheckInit(M, Sess, HistoryIST', < empty, empty >, IST) --- filter initial and other states
    /\ IST'' := filterStates(F, HistoryIST', IST', C)
    /\ C' := #jobs(IST'')
    /\ D' := (D + Step)
    /\ N' := #jobs(INIT INIT')
    [print "<================= [Switch at Depth " D' " #jobs = " C' " #init = " N' "] =================>"] .

    rl [Resuming] : < O : Manager |
        status : suspending,
        jobs : IST,
        filter : F,
        history : HistoryIST,
        bStep : BStep,
        rem : Rem?,
        A >
    => if BStep == 0 or-else IST == empty then
        --- Stop the search
        < O : Manager |
            status : stopping,
            jobs : IST,
            filter : F,
            history : HistoryIST,
            bStep : BStep,
            rem : Rem?,
            A >
        stopWorking(O, O)
    else
        < O : Manager |
            status : working,
            jobs : IST,
            filter : F,
            history : HistoryIST,
            bStep : BStep,
            rem : Rem?,
            A >
    fi .

    crl [terminate] : < O : Manager |
        status : working,
        nWorkers : N,
        workers : W,
        jobs : empty,
        next : empty,
        A >
    => < O : Manager |
        status : stopping,
        nWorkers : N,
        workers : W,
        jobs : empty,
        next : empty,
        A >
        stopWorking(O, O)
    if qsize(W) == N
    [print "[terminate]"] .

    rl [StopWorkers] : < O : Manager |
        workers : W,
        A >
        stopWorking(O, O')
    => < O : Manager |
        workers : W,
        A >
        produceQuitMsg(O, W)
        [print "[StopWorkers]"] .

    op produceQuitMsg : Oid Queue{Worker} -> Configuration .
    eq produceQuitMsg(O, (MI | W)) = quit(MI, O) produceQuitMsg(O, W) .
    eq produceQuitMsg(O, emptyq) = none .

    rl [Bye] : < O : Manager |
        workers : (MI | W),
        A >
        bye(O, MI)
    => < O : Manager |
        workers : W,
        A >
        [print "[Bye]"] .

    rl [CleanUp] : < O : Manager |
        status : stopping,
        workers : emptyq,
        filter : F,
        jobs : IST,
        rem : Rem?,
        init : INIT,
        A >
    => ShortIdSystem: if Rem? then
            changeShortSystem(F, INIT IST)
        else
            changeShortSystem(F, INIT)
        fi
        [print "[CleanUp]"] .
endm